#!/usr/local/env python
#-*- coding: UTF-8 -*-

'''
Some useful functions for penetration test.
'''

__author__ = "alpha1e0"

import argparse
import os

SMALLSIZE = 3000
NORMALSIZE = 10000


class PenError(Exception):
    def __init__(self, errorMsg):
        self.errorMsg = errorMsg

    def __str__(self):
        return str(self.errorMsg)


class DictError(PenError):
    def __str__(self):
        return str(" ".join(["Dict error", self.errorMsg]))


def WordList(fileName):
    result = set()
    if os.path.exists(fileName):
        with open(fileName, "r") as fd:
            for line in fd:
                if line.strip() :
                    yield line


class Database(object):
    def __init__(self, dbfile):
        self.dbfile = dbfile
        self.list = []
        self._load()


    def _load(self):
        try:
            with open(self.dbfile, "r") as fd:
                for line in fd:
                    if line:
                        splited = line.strip().split(" ")
                        self.list.append([splited[0].strip(), int(splited[1])])
        except IOError as error:
            print "[!]: read all-file error, reason: " + str(error) + "loads empty."


    def dump(self, cast=False):
        self.list.sort(key=lambda x: x[1], reverse=True)
        try:
            with open(self.dbfile, "w") as fd:
                for line in self.list:
                    fd.write("{0} {1}\n".format(line[0],line[1]))
        except IOError:
            raise DictError()

        if cast:
            try:
                smallFD = open(self.dbfile+"_small.txt","w")
                normalFD = open(self.dbfile+"_normal.txt","w")
                largeFD = open(self.dbfile+"_large.txt","w")
            except IOError:
                raise DictError()

            dblen = len(self.list)
            small = SMALLSIZE if SMALLSIZE<dblen else dblen
            normal = NORMALSIZE if NORMALSIZE<dblen else dblen
            large = dblen
            for i in range(dblen):
                if i < small:
                    smallFD.write(self.list[i][0]+"\n")
                    normalFD.write(self.list[i][0]+"\n")
                    largeFD.write(self.list[i][0]+"\n")
                elif i < normal:
                    normalFD.write(self.list[i][0]+"\n")
                    largeFD.write(self.list[i][0]+"\n")
                else:
                    largeFD.write(self.list[i][0]+"\n")

            smallFD.close()
            normalFD.close()
            largeFD.close()


    def add(self, word):
        for line in self.list:
            if word == line[0]:
                line[1] += 1
        else:
            self.list.append([word, 1])


#================================sub commands=====================================

def doDictAdd(args):
    rawDictFiles = os.listdir(args.sourcedir)
    print "debug:>>>>>rawDictFiles", rawDictFiles
    dbfile = args.database

    db = Database(dbfile)
    for dictfile in rawDictFiles:
        dictfile = os.path.join(args.sourcedir, dictfile)
        for line in WordList(dictfile):
            #print "debug:>>>>>read line", line, "from", dictfile
            db.add(line.strip())

    db.dump(True)


def doGenPicShell(args):
    with open(args.pic, "rb") as fd:
        picData = fd.read()
    with open(args.shell, "rb") as fd:
        shellData = fd.read()
    with open(args.dest, "wb") as fd:
        fd.write(picData)
        fd.write(shellData)


#=====================================main================================================

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    subparser = parser.add_subparsers(title="subcommands", description="use subcommands")

    dictadd = subparser.add_parser("dictadd", help="add wordlist to database")
    dictadd.add_argument("sourcedir",help="specified the source worldlist directory.")
    dictadd.add_argument("database",help="specified the all dict file.")
    dictadd.set_defaults(func=doDictAdd)

    picshell = subparser.add_parser("picshell", help="generate picture webshell")
    picshell.add_argument("pic",help="specified the picture file or other files to contain the webshell.")
    picshell.add_argument("shell",help="specified the shell file.")
    picshell.add_argument("dest",help="specified the output file.")
    picshell.set_defaults(func=doGenPicShell)

    args = parser.parse_args()
    args.func(args)


